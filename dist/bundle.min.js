(function () {
  'use strict';

  function _isPlaceholder(a) {
         return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };
      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        }
        combinedIdx += 1;
      }
      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  }

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      const sumArgs = (...args) => R.sum(args);
   *
   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */
  var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }
    return _arity(length, _curryN(length, [], fn));
  });

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  var _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };

  function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
  }

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer [xf] to return a new transformer (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} xf transducer to initialize if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */
  function _dispatchable(methodNames, xf, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }
      var args = Array.prototype.slice.call(arguments, 0);
      var obj = args.pop();
      if (!_isArray(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, args);
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = xf.apply(null, args);
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  var _xfBase = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };

  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);
    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  }

  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   */
  var _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }
    if (!x) {
      return false;
    }
    if (typeof x !== 'object') {
      return false;
    }
    if (_isString(x)) {
      return false;
    }
    if (x.nodeType === 1) {
      return !!x.length;
    }
    if (x.length === 0) {
      return true;
    }
    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }
    return false;
  });

  var XWrap = /*#__PURE__*/function () {
    function XWrap(fn) {
      this.f = fn;
    }
    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };
    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };
    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return XWrap;
  }();

  function _xwrap(fn) {
    return new XWrap(fn);
  }

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      const log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */
  var bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });

  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

  function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (_isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list['fantasy-land/reduce'] === 'function') {
      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
  }

  var XMap = /*#__PURE__*/function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;
    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return XMap;
  }();

  var _xmap = /*#__PURE__*/_curry2(function _xmap(f, xf) {
    return new XMap(f, xf);
  });

  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var toString = Object.prototype.toString;
  var _isArguments = /*#__PURE__*/function () {
    return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();

  // cover IE < 9 keys issues
  var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = /*#__PURE__*/function () {

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */
  var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? /*#__PURE__*/_curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /*#__PURE__*/_curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex
   * @example
   *
   *      const double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */
  var map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });
      case '[object Object]':
        return _reduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));
      default:
        return _map(fn, functor);
    }
  }));

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */
  var reduce = /*#__PURE__*/_curry3(_reduce);

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN, R.partial
   * @example
   *
   *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
   *
   *      const curriedAddFourNumbers = R.curry(addFourNumbers);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */
  var curry = /*#__PURE__*/_curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });

  /**
   * Returns the nth element of the given list or string. If n is negative the
   * element at index length + n is returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> a | Undefined
   * @sig Number -> String -> String
   * @param {Number} offset
   * @param {*} list
   * @return {*}
   * @example
   *
   *      const list = ['foo', 'bar', 'baz', 'quux'];
   *      R.nth(1, list); //=> 'bar'
   *      R.nth(-1, list); //=> 'quux'
   *      R.nth(-99, list); //=> undefined
   *
   *      R.nth(2, 'abc'); //=> 'c'
   *      R.nth(3, 'abc'); //=> ''
   * @symb R.nth(-1, [a, b, c]) = c
   * @symb R.nth(0, [a, b, c]) = a
   * @symb R.nth(1, [a, b, c]) = b
   */
  var nth = /*#__PURE__*/_curry2(function nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  });

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> ''
   */
  var head = /*#__PURE__*/nth(0);

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> ''
   */
  var last = /*#__PURE__*/nth(-1);

  class FaderController {

  	constructor(options, mountPoint) {

  		this.min = options.min || 0;
  		this.max = options.max || 0.95;
  		this.step = options.step || 0.05;
  		this.value = options.value || 0;
   
  		this.isVertical = options.vertical || false;

  		this.onChange = options.onChange || null;


  		this.dragStart = this.onMouseDown.bind(this);
  		this.drag = this.onMouseMove.bind(this);
  		this.dragEnd = this.onMouseUp.bind(this);


  		this.el = this.layout();

  		if (mountPoint) {
  			this.mount(mountPoint);
  		}
  	}


  	get offset() {

  		return this.el.getBoundingClientRect()
  	}


  	onMouseDown(event) {

  		event.preventDefault();

  		document.documentElement.addEventListener('ontouchstart' in window ? 'touchmove' : 'mousemove', this.drag);
  		document.documentElement.addEventListener('ontouchstart' in window ? 'touchend' : 'mouseup', this.dragEnd);

  		return false
  	}

  	onMouseMove(event) {

  		event.preventDefault();

  		let trigger = this.el.querySelector('.input__trigger');
  		let offset = this.offset;
  		let percentage = 0;

  		if (this.isVertical) {

  			let y = event.touches ? event.touches[0].pageY : event.pageY;


  			if (y < offset.top) {
  				y = offset.top;
  			}

  			if (y > offset.bottom) {
  				y = offset.bottom;
  			}


  			trigger.style.bottom = (offset.bottom - y) + 'px';

  			percentage = (offset.bottom - y) / (offset.height / 100);

  		} else {

  			let x = event.touches ? event.touches[0].pageX : event.pageX;
  			let rightBorder = offset.left + offset.width;


  			if (x > rightBorder) {
  				x = rightBorder;
  			}

  			if (x < offset.left) {
  				x = offset.left;
  			}

  			trigger.style.left = (x - offset.left) + 'px';

  			percentage = (x - offset.left) / (offset.width / 100);

  		}

  		this.value = this.max * (percentage / 100);

  		this.el.setAttribute('data-value', this.value);


  		if (typeof this.onChange === 'function') {

  			this.onChange(this.value);
  		}
  	}

  	onMouseUp() {

  		document.documentElement.removeEventListener('ontouchstart' in window ? 'touchmove' : 'mousemove', this.drag);
  		document.documentElement.removeEventListener('ontouchstart' in window ? 'touchend' : 'mouseup', this.dragEnd);
  	}


  	layout() {

  		let element = document.createElement('div');
  		let elementTrigger = document.createElement('div');

  		element.appendChild(elementTrigger);
  		element.classList.add('input', 'input--range', 'fader__control');


  		if (!this.isVertical) {

  			element.classList.add('fader__control--horizontal');
  			elementTrigger.style.left = this.value / (this.max / 100) + '%';

  		} else {

  			elementTrigger.style.bottom = this.value / (this.max / 100) + '%';

  		}


  		elementTrigger.classList.add('input__trigger', 'fader__control-value');

  		element.setAttribute('data-min', this.min);
  		element.setAttribute('data-max', this.max);
  		element.setAttribute('data-value', this.value);
  		element.setAttribute('data-step', this.step);

  		element.querySelector('.input__trigger').addEventListener('ontouchstart' in window ? 'touchstart' : 'mousedown', this.dragStart);

  		return element
  	}

  	mount(mountPoint) {

  		let mp = (typeof mountPoint === 'string') ? document.querySelector(mountPoint) : mountPoint;

  		if (mp) {
  			mp.appendChild(this.el);
  		}
  	}

  	animateTo(value) {

  		this.value = value;


  		let trigger = this.el.querySelector('.fader__control-value');

  		trigger.addEventListener('transitionend', e => {
  			trigger.classList.remove('fader__control-value--animated');
  		});

  		trigger.classList.add('fader__control-value--animated');

  		trigger.style.bottom = (this.value / this.max * 100) + '%';
  	}
  }

  let Template = `<div class="fader">
					<div data-name="fader" class="fader__placeholder"></div>
					<div class="fader__buttons">
						<button class="fader__button button" data-name="mute">Mute</button>
						<button class="fader__button button" data-name="bypass">Bypass FX</button>
					</div>
					<div class="fader__effects">
						<div class="fader__effect">
							<span class="fader__effect-title">Delay:</span>
							<div class="fader__effect-placeholder" data-type="fader" data-fx="delay" data-max="0.95" data-step="0.05"></div>
						</div>
						<div class="fader__effect">
							<span class="fader__effect-title">Revrb:</span>
							<div class="fader__effect-placeholder" data-type="fader" data-fx="reverb" data-max="0.95" data-step="0.05"></div>
						</div>
						<div class="fader__effect">
							<span class="fader__effect-title">Distrt:</span>
							<div class="fader__effect-placeholder" data-type="fader" data-fx="distortion" data-max="0.95" data-step="0.05"></div>
						</div>
					</div>
					<div class="fader__title" data-name="title"></div>
				</div>`;

  class TrackController {

  	constructor(options) {

  		this.track = options.track;
  		this.mountPoint = options.mountPoint;

  		this.template = document.createElement('template');
  		this.template.innerHTML = Template;


  		this.el = this.layout();
  	}

  	layout() {

  		let track = this.track;
  		let element = document.importNode(this.template.content, true);


  		element.querySelector('[data-name="title"]').textContent = track.title;


  		element.querySelector('[data-name="mute"]').addEventListener('click', e => {
  			track.toggleMute();
  			e.currentTarget.classList.toggle('button--pressed', track.muted);
  		});


  		element.querySelector('[data-name="bypass"]').addEventListener('click', e => {
  			track.toggleFX();
  			e.currentTarget.classList.toggle('button--pressed', track.bypassFX);
  		});



  		let fader = element.querySelector('[data-name="fader"]');

  		let faderView = new FaderController({
  			min: 0,
  			max: 1,
  			step: 0.05,
  			value: track.ready ? 1 : 0,
  			vertical: true,
  			onChange: function(value) {
  				track.volume = value;
  			}
  		}, fader);


  		if (!track.ready) {

  			track.onReady = function(track) {
  				faderView.animateTo(1);
  			};

  		}



  		let faders = element.querySelectorAll('[data-type="fader"]');

  		for (let i = 0; i < faders.length; i++) {

  			let fxIdent = faders[i].getAttribute('data-fx');

  			let fader = new FaderController({
  				min: 0,
  				max: 0.95,
  				value: 0,
  				step: 0.05,
  				onChange: function(value) {
  					track.fx[fxIdent].gain.value = value;
  				}
  			}, faders[i]);
  		}



  		if (this.mountPoint) {
  			this.mountPoint.appendChild(element);
  		}

  		return element
  	}
  }

  let Template$1 = `<div class="desk">
					<div class="desk__faders" data-name="tracks"></div>
				</div>
				<div class="desk__addons">
					<div class="desk__controls">
						<div class="desk__control-meter">
							<canvas class="desk__control-meter-value" width="210" height="20" data-name="master-level"></canvas>
						</div>
						<button class="desk__control" data-name="play" disabled><span class="icon icon--play"></span> play</button>
						<button class="desk__control" data-name="pause" disabled><span class="icon icon--pause"></span> pause</button>
						<button class="desk__control" data-name="rewind" disabled><span class="icon icon--rewind"></span> rewind</button>
					</div>
					<div class="effects">
						<div class="effects__item effect" data-name="effect-delay">
							<div class="effect__title">Delay</div>
							<div class="effect__param">
								<span class="effect__param-title">Time:</span>
								<div class="effect__param-placeholder" data-type="fader" data-param="delay.time" data-value="0.25" data-name="delay-time"></div>
							</div>
							<div class="effect__param">
								<span class="effect__param-title">Feedback:</span>
								<div class="effect__param-placeholder" data-type="fader" data-param="delay.feedback" data-value="0.8" data-name="delay-feedback"></div>
							</div>
							<div class="effect__param">
								<span class="effect__param-title">Cutoff:</span>
								<div class="effect__param-placeholder" data-type="fader" data-param="delay.frequency" data-max="4000" data-step="10" data-value="1120" data-name="delay-frequency"></div>
							</div>
						</div>
						<div class="effects__item effect" data-name="effect-distortion">
							<div class="effect__title">Distortion</div>
							<div class="effect__param">
								<span class="effect__param-title">Filter:</span>
								<label>High <input class="input input--radio" name="distortion-filterType" type="radio" value="highpass" checked data-name="distortion-filterType" /></label>
								<label>Low <input class="input input--radio" name="distortion-filterType" type="radio" value="lowpass"  data-name="distortion-filterType" /></label>
								<label>Band <input class="input input--radio" name="distortion-filterType" type="radio" value="bandpass" data-name="distortion-filterType" /></label>
							</div>
							<div class="effect__param">
								<span class="effect__param-title">Frequency:</span>
								<div class="effect__param-placeholder" data-type="fader" data-param="distortion.frequency" data-step="10" data-max="20000" data-value="70" data-name="distortion-frequency"></div>
							</div>
							<div class="effect__param">
								<span class="effect__param-title">Strength:</span>
								<div class="effect__param-placeholder" data-type="fader" data-param="distortion.strength" data-step="10" data-max="200" data-value="200" data-name="distortion-strength"></div>
							</div>
						</div>
					</div>
				</div>`;

  const createContext = () => new window.AudioContext();

  const createMasterBus = (context, connections = []) => {
      const gain = context.createGain();

      gain.connect(context.destination);
      connections.map(connection => gain.connect(connection));

      return gain;
  };

  const createAnalyser = (context, parameters = {fftSize: 2048}) => {
      const analyser = context.createAnalyser();

      keys(parameters).map(key => analyser[key] = parameters[key]);

      return analyser;
  };

  const createTrackFromSource = curry((context, masterBus, {url, title}) => new Track({
      url,
      title,
      context,
      masterBus,
  }));

  const isAudioParam = (node, parameter) => node[parameter] instanceof AudioParam;

  const fetchAudioAsArrayBuffer = url => fetch(url).then(response => response.audioBuffer());

  const setNodeParams = (node, params) => keys(params).forEach(key => {
      if (isAudioParam(node, key)) {
          node[key].value = params[key];
      } else {
          node[key] = params[key];
      }

      return node;
  });


  const connectNodes = (source, destination) => 
      source.connect(destination);

  const connectNodesSingle = (source, destination) => {
      source.disconnect();
      connectNodes(source, destination);
  };

  const createGainNode = (context, defaultVolume = 1) => {
      const gain = context.createGain();
      gain.gain.value = defaultVolume;

      return gain;
  };

  class Track {
  	constructor({url, title, context, masterBus}) {
  		this.source = null;
  		this.buffer = null;

  		this.title = title;
  		this.context = context;

  		this.pausedAt = 0;
  		this.startedAt = 0;

  		this.muted = false;
  		this.playing = false;
  		this.ready = false;
  		this.bypassFX = false;

  		this.fx = {};


  		this.bus = context.createGain();
  		this.bus.gain.value = 1;
  		this.bus.connect(masterBus);

  		this.loadingState = this.load(url);
  	}


  	get volume() {
  		return this.bus.gain.value;
  	}

  	set volume(value) {
  		if (this.muted) {
  			this.previousVolume = value;
  		} else {
  			this.bus.gain.value = value;
  		}
  	}

  	load(url) {
  		return fetchAudioAsArrayBuffer(url)
  			.then(audioBuffer => this.context.decodeAudioData(audioBuffer))
  			.then(decodedAudioData => {
  				this.buffer = decodedAudioData;
  				this.ready = true;

  				console.log('Track "%s" is ready', this.title);

  				return this;
  			})
  			.catch(error => console.log('[ERROR LOADING TRACK]', error));
  	}


  	play() {
  		if (this.playing) {
  			return false;
  		}

  		this.source = this.context.createBufferSource();
  		this.source.buffer = this.buffer;
  		this.source.connect(this.bus);
  		this.source.start(0, this.pausedAt);

  		this.startedAt = this.context.currentTime - this.pausedAt;
  		this.pausedAt = 0;
  		this.playing = true;
  	}

  	pause() {
  		const elapsed = this.context.currentTime - this.startedAt;
  		this.stop();
  		this.pausedAt = elapsed;
  	}

  	stop() {
  		if (this.source) {
  			this.source.disconnect();
  			this.source.stop(0);
  			this.source = null;
  		}

  		this.pausedAt = 0;
  		this.startedAt = 0;
  		this.playing = false;
  	}

  	mute() {
  		this.previousVolume = this.volume;
  		this.volume = 0;
  		this.muted = true;
  	}

  	unmute() {
  		this.muted = false;
  		this.volume = this.previousVolume;
  	}

  	toggleMute() {
  		this.muted ? this.unmute() : this.mute();
  	}

  	addFx(effects) {
  		return effects.map(fx => {
  			const {id, signalIn} = fx;
  			const bus = this.context.createGain();

  			if (this.fx[id]) {
  				return false;
  			}

  			connectNodes(this.bus, bus);
  			connectNodes(bus, signalIn);

  			bus.gain.value = 0;

  			return bus;
  		});
  	}

  	removeFx(id) {
  		this.fx[id].disconnect();
  	}

  	toggleFX() {
  		const fxNames = Object.keys(this.fx);

  		if (this.bypassFX) {

  			fxNames.forEach(fxName => {
  				this.fx[fxName].gain.value = this.fx[fxName].previousVolume;
  			});

  		} else {

  			fxNames.forEach(fxName => {
  				this.fx[fxName].previousVolume = this.fx[fxName].gain.value;
  				this.fx[fxName].gain.value = 0;
  			});

  		}

  		this.bypassFX = !this.bypassFX;
  	}
  }

  class FX {
  	constructor({id, context, masterBus}) {
  		this.id = id;
  		this.isLooped = false;
  		this.chain = [];

  		this.signalIn = createGainNode(context);
  		this.signalOut = createGainNode(context);

  		connectNodes(this.signalOut, masterBus);
  	}

  	get isChainEmpty() {
  		return this.chain.length === 0;
  	}

  	get gain() {
  		return this.signalIn.gain.value;
  	}

  	set gain(value) {
  		this.signalIn.gain.value = value;
  	}

  	addNode(node, parameters = {}) {
  		setNodeParams(node, parameters);

  		this.isChainEmpty
  			? connectNodes(this.signalIn, node)
  			: connectNodesSingle(last(this.chain), node);

  		connectNodes(node, this.signalOut);

  		this.chain.push(node);
  	}

  	tweakNode(nodeIndex, parameter, value) {
  		const node = this.chain[nodeIndex];

  		if (!node) {
  			return false;
  		}

  		return setNodeParams(node, {
  			[parameter]: value,
  		});
  	}

  	set loop(value) {
  		const lastNode = last(this.chain);
  		const firstNode = head(this.chain);

  		connectNodes(lastNode, firstNode);

  		this.isLooped = value;
  	}

  	get loop() {
  		return this.isLooped;
  	}
  }

  class Delay extends FX {
  	constructor(context, masterBus) {
  		super({
  			context,
  			masterBus,
  			id: 'delay',
  		});

  		this.addNode(context.createDelay(), {
  			delayTime: 0.25,
  		});

  		this.addNode(context.createGain(), {
  			gain: 0.8,
  		});

  		this.addNode(context.createBiquadFilter(), {
  			frequency: 1120,
  		});

  		this.loop = true;
  	}

  	set time(value) {
  		this.tweakNode(0, 'delayTime', value);
  	}

  	set feedback(value) {
  		this.tweakNode(1, 'gain', value);
  	}

  	set frequency(value) {
  		this.tweakNode(2, 'frequency', value);
  	}
  }

  const RESPONSE_URL = '/assets/audio/reverb-impulse-response.wav';

  class Reverb extends FX {
  	constructor(context, masterBus) {
  		super({
  			context,
  			masterBus,
  			id: 'reverb',
  		});

  		this.addNode(context.createConvolver());
  		this.loadResponse(RESPONSE_URL);
  	}

  	async loadResponse(url) {
  		const arrayBuffer = 
  			await fetchAudioAsArrayBuffer(url)
  				.catch(error => console.log('[ERROR LOADING RESPONSE]', error));

  		if (arrayBuffer) {
  			const decodedData = await this.context.decodeAudioData(arrayBuffer);

  			this.tweakNode(0, 'buffer', decodedData);
  		}
  	}
  }

  class Distortion extends FX {
  	constructor(context, masterBus) {
  		super({
  			context,
  			masterBus,
  			id: 'distortion',
  		});

  		this._strength = 200;

  		this.addNode(context.createBiquadFilter(), {
  			type: 'highpass',
  			frequency: 138,
  			Q: 1
  		});

  		this.addNode(context.createWaveShaper(), {
  			curve: this.getCurve(this._strength),
  			oversample: '4x'
  		});
  	}

  	set filterType(value) {
  		this.tweakNode(0, 'type', value);
  	}

  	set frequency(value) {
  		this.tweakNode(0, 'frequency', value);
  	}

  	set strength(value) {
  		this._strength = value;
  		this.tweakNode(1, 'curve', this.getCurve(value));
  	}

  	getCurve(strength) {
  		var k = typeof strength === 'number' ? strength : 50,
  			n_samples = 44100,
  			curve = new Float32Array(n_samples),
  			deg = Math.PI / 180,
  			i = 0,
  			x;

  		for (; i < n_samples; ++i) {
  			x = i * 2 / n_samples - 1;
  			curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
  		}

  		return curve
  	}
  }

  const playAll = map(track => track.play());

  const pauseAll = map(track => track.pause());

  const rewindAll = map(track => {
      track.stop();
      track.play();
  });

  class Mixer {
  	constructor(sources, onReady) {
  		this.context = createContext();
  		this.analyser = createAnalyser(this.context);
  		this.masterBus = createMasterBus(this.context, [this.analyser]);
  		
  		this.tracks = [];

  		this.fx = [
  			new Delay(this.context, this.masterBus),
  			new Reverb(this.context, this.masterBus),
  			new Distortion(this.context, this.masterBus),
  		];

  		const trackPromises = map(createTrackFromSource(this.context, this.masterBus), sources);

  		Promise.all(trackPromises)
  			.then(map(track => track.addFx(this.fx)))
  			.then(map(track => this.tracks.push(track)))
  			.then(map(onReady));
  	}

  	play() {
  		return playAll(this.tracks);
  	}

  	pause() {
  		return pauseAll(this.tracks);
  	}

  	rewind() {
  		return rewindAll(this.tracks);
  	}
  }

  const COLOR_GREEN = '#05860f';
  const COLOR_YELLOW = '#f9ef5c';
  const COLOR_RED = '#861615';

  /**
   * @param {AudioContext} context
   * @param {Canvas} canvas
   * @returns {CanvasGradient}
   */
  const createMeterGradient = (context, {
  	width,
  	height
  }) => {
  	const gradient = context.createLinearGradient(0, 0, width, height);

  	gradient.addColorStop(0.0, COLOR_GREEN);
  	gradient.addColorStop(0.8, COLOR_YELLOW);
  	gradient.addColorStop(0.9, COLOR_RED);

  	return gradient;
  };

  /**
   * @param {Number[]} items
   * @returns {Number}
   */
  const getAverage = items => reduce((acc, item) => acc += item, 0, items) / items.length;



  class MixerController {

  	constructor(sources, mountPoint) {
  		this.mixer = new Mixer(sources, this.enablePlayback.bind(this));
  		this.tracks = [];
  		this.mountPoint = (typeof mountPoint === 'string') ? document.querySelector(mountPoint) : mountPoint;
  		this.template = document.createElement('template'); //document.querySelector(template || '#desk')
  		this.template.innerHTML = Template$1;
  		this._fillStyle = null;

  		this.bootstrap();
  	}

  	get canvas() {
  		return this.mountPoint.querySelector('[data-name="master-level"]')
  	}

  	get context() {
  		return this.canvas.getContext('2d');
  	}

  	get fillStyle() {
  		this._fillStyle = this._fillStyle || createMeterGradient(this.context, this.canvas);

  		return this._fillStyle;
  	}


  	bootstrap() {
  		let tracks = this.buildTracks();
  		let mixer = this.buildMixer();

  		mixer.querySelector('[data-name="tracks"]').appendChild(tracks);

  		let mountPoint = this.mountPoint;

  		while (mountPoint.firstChild) {
  			mountPoint.removeChild(mountPoint.firstChild);
  		}

  		mountPoint.appendChild(mixer);

  		this.drawMeter();
  	}

  	buildTracks() {

  		let wrapper = document.createDocumentFragment();

  		this.tracks = this.mixer.tracks.map(track => new TrackController({
  			track: track,
  			mountPoint: wrapper
  		}));

  		return wrapper
  	}

  	buildMixer() {
  		let template = this.template;
  		let element = document.importNode(template.content, true);

  		element.querySelector('[data-name="play"]').addEventListener('click', this.mixer.play.bind(this.mixer));
  		element.querySelector('[data-name="pause"]').addEventListener('click', this.mixer.pause.bind(this.mixer));
  		element.querySelector('[data-name="rewind"]').addEventListener('click', this.mixer.rewind.bind(this.mixer));


  		let effects = element.querySelectorAll('[data-type="fader"]');

  		for (let i = 0; i < effects.length; i++) {

  			let effect = effects[i];
  			let param = effect.getAttribute('data-param');
  			let paramChain = param.split('.');

  			let effectInput = new FaderController({
  				min: 0,
  				max: effect.getAttribute('data-max'),
  				step: effect.getAttribute('data-step'),
  				value: effect.getAttribute('data-value'),
  				onChange: (value) => {
  					let fx = this.mixer.fx.filter(fx => paramChain[0] === fx.id)[0];

  					if (fx) {
  						fx[paramChain[1]] = value;
  					}
  				}

  			}, effect);
  		}

  		return element
  	}

  	drawMeter() {
  		let canvas = this.canvas;
  		let context = this.context;
  		let analyser = this.mixer.analyser;

  		let array = new Uint8Array(analyser.frequencyBinCount);

  		analyser.getByteFrequencyData(array);

  		const average = getAverage(array);

  		context.clearRect(0, 0, canvas.width, canvas.height);
  		context.fillStyle = this.fillStyle;
  		context.fillRect(0, 0, (canvas.width / 100) * average, canvas.height);

  		requestAnimationFrame(this.drawMeter.bind(this));
  	}

  	enablePlayback(tracks) {
  		const controls = this.mountPoint.querySelectorAll('.desk__control');

  		controls.forEach(control => control.removeAttribute('disabled'));

  		console.log('Tracks %o loaded', tracks);
  	}
  }

  var sources = [
  	{
  		title : 'Drums',
  		url : 'assets/audio/drums.mp3'
  	},
  	{
  		title : 'Bass',
  		url : 'assets/audio/bass.mp3'
  	},
  	{
  		title : 'Keys',
  		url : 'assets/audio/keys.mp3'
  	},
  	{
  		title : 'Melodies',
  		url : 'assets/audio/melodies.mp3'
  	},
  	{
  		title : 'Vox',
  		url : 'assets/audio/vox.mp3'
  	}
  ];

  new MixerController(sources, '.application');

}());
